//============================================================================
// top.v
//
// Do not modify this file (unless you are sure you need to)
//
// This code is generated by Terasic System Builder and modified by 
// M. Hildebrand and B. Baas
//
// 2018/02/05 First version
// 2018/04/24 Routed all board-level push buttons and switches to, and LEDs 
//            and displays from, the module comb_ckt_generator
//============================================================================

module top (
   //////////// CLOCKS //////////
   input               ADC_CLK_10,
   input               MAX10_CLK1_50,
   input               MAX10_CLK2_50,

   //////////// VGA SIGNALS //////////
   output reg [3:0]    VGA_R,
   output reg [3:0]    VGA_G,
   output reg [3:0]    VGA_B,
   output reg          VGA_HS,
   output reg          VGA_VS,

   //////////// KEYs //////////
   input      [1:0]    KEY,    // two board-level push buttons KEY1 - KEY0

   //////////// SWs //////////
   input      [9:0]    SW,     // ten board-level switches SW9 - SW0

   //////////// LEDs //////////
   output     [9:0]    LEDR   // ten board-level LEDs LEDR9 - LEDR0

);

// Signals for drawing to the display. 
wire [31:0]    col, row;
wire [3:0]     red, green, blue, r, g ,b, gray_out, wr_gx, wr_gy;

// Timing signals 
wire           h_sync, v_sync;
wire           disp_ena;
wire           vga_clk;
wire sobel_done, gen_done;

wire gen_en, sobel_en, w_en3;
wire [3:0] rVGA, gVGA, bVGA;
wire [5:0] current_state;
wire rst;
wire [11:0] rom, mem;
wire  [11:0] wr_data;
wire [11:0] gray_mem;
wire [11:0] Gx_out, Gy_out, Gx_in, Gy_in;

wire [9:0]  wr_addr, gen_addr, Q_addr;
wire  [9:0] 	 vga_addr;
assign	vga_addr = { row[5:0], col[5:0]};

assign rst = ~KEY[0];
wire clk;
//// DISPLAY INTERFACE: SW[9] Gx memory, SW[8] grayscale memory , SW[1] Gy memory

pulsegen gen (MAX10_CLK1_50, rst, clk);

ROM toDisplay( 1'b1, vga_addr, red, green, blue, mem); //reading addresses such that VGA can read to display
ROM toREAD( 1'b1, gen_addr, r, g, b, rom); //reading addresses such that VGA can read to display
addressGen u2(vga_clk, 1'b0, gen_en, sobel_en, gen_addr, gen_done);
grayScale gray(vga_clk, rom, gray_out);		
assign wr_data = {gray_out, gray_out, gray_out};
memOp graySobel(vga_clk, gen_en, 1'b1, sobel_en, gen_addr,wr_data, vga_addr, gray_mem, wr_gx, wr_gy, sobel_done);
assign Gy_in = {wr_gy, wr_gy, wr_gy};///? !
assign  Gx_in = {wr_gx,wr_gx,wr_gx}; // 
//holds horizontal operator resultant
memory Gx(vga_clk, 1'b1, sobel_en, gen_addr, Gx_in, vga_addr, Gx_out);
memory Gy(vga_clk, 1'b1, sobel_en, gen_addr, Gy_in, vga_addr, Gy_out);//holds vertical operator resultant

FSM fssm(clk, rst,SW[0], gen_done, sobel_done, gen_en, sobel_en, current_state);
assign LEDR = current_state;


displaySelector  disp(clk, SW[3:1], SW[9], SW[8], gen_addr, vga_addr, gray_mem,  Gx_out, Gy_out,current_state, red, green, blue, rVGA, bVGA, gVGA, Q_addr);


//============================================================================
// Display-related and PLL stuff. Don't touch!
//============================================================================

always @(posedge vga_clk) begin
   if (disp_ena == 1'b1) begin
		///multiplex here to display black where the image is out of bounds"?		
		VGA_R <=  rVGA;
		VGA_G <=  gVGA;
      VGA_B <=  bVGA;
   end else begin
      VGA_R <= 4'd0;
      VGA_B <= 4'd0;
      VGA_G <= 4'd0;
   end
   VGA_HS <= h_sync;
   VGA_VS <= v_sync;
end

// Instantiate PLL to convert the 50 MHz clock to a 25 MHz clock for timing.
pll vgapll_inst (
    .inclk0    (MAX10_CLK1_50),
    .c0        (vga_clk)
    );

// Instantite VGA controller
vga_controller control (
   .pixel_clk  (vga_clk),
   .reset_n    (KEY[0]),
   .h_sync     (h_sync),
   .v_sync     (v_sync),
   .disp_ena   (disp_ena),
   .column     (col),
   .row        (row)
   );

endmodule
